/*
 * GPLv3 License
 *
 *  Copyright (c) KAGA by waicool20
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

package com.waicool20.kaga.config

import com.fasterxml.jackson.annotation.JsonIgnore
import com.fasterxml.jackson.annotation.JsonProperty
import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper
import com.waicool20.kaga.Kaga
import com.waicool20.kaga.util.IniConfig
import com.waicool20.kaga.util.fromObject
import com.waicool20.kaga.util.toObject
import javafx.beans.property.*
import javafx.collections.FXCollections
import org.ini4j.Wini
import org.slf4j.LoggerFactory
import tornadofx.*
import java.io.StringWriter
import java.nio.file.Files
import java.nio.file.Path
import java.nio.file.StandardOpenOption
import java.util.*
import java.util.regex.Pattern


class KancolleAutoProfile(
        name: String = KancolleAutoProfile.Loader.DEFAULT_NAME,
        val general: General = General(),
        val scheduledSleep: ScheduledSleep = ScheduledSleep(),
        /* TODO Disabled temporarily till kcauto-kai is finalized
        val scheduledStop: ScheduledStop = ScheduledStop(),*/
        val expeditions: Expeditions = Expeditions(),
        val pvp: Pvp = Pvp(),
        val sortie: Sortie = Sortie(),
        /* TODO Disabled temporarily till kcauto-kai is finalized
        val submarineSwitch: SubmarineSwitch = SubmarineSwitch()*/
        val quests: Quests = Quests()
) {
    private val logger = LoggerFactory.getLogger(KancolleAutoProfile::class.java)
    @JsonIgnore
    var nameProperty = SimpleStringProperty(name)
    @get:JsonProperty
    var name by nameProperty

    fun path(): Path = Kaga.CONFIG_DIR.resolve("$name-config.ini")

    fun save(path: Path = path()) {
        logger.info("Saving KancolleAuto profile")
        logger.debug("Saving to $path")
        if (Files.notExists(path)) {
            logger.debug("Profile not found, creating file $path")
            Files.createDirectories(path.parent)
            Files.createFile(path)
        }
        val config = asIniString().replace("true", "True").replace("false", "False")
        val header = "# Configuration automatically generated by KAGA\n"
        Files.write(path, (header + config).toByteArray(), StandardOpenOption.TRUNCATE_EXISTING)
        logger.info("Saving KancolleAuto profile was successful")
        logger.debug("Saved $this to $path")
    }

    fun asIniString() = StringWriter().also { getIni().store(it) }.toString()

    private fun getIni() = Wini().apply {
        add("General").fromObject(general)
        add("ScheduledSleep").fromObject(scheduledSleep)
        /* TODO Disabled temporarily till kcauto-kai is finalized
        add("ScheduledStop").fromObject(scheduledStop)*/
        add("Expeditions").fromObject(expeditions)
        add("PvP").fromObject(pvp)
        add("Combat").fromObject(sortie)
        /* TODO Disabled temporarily till kcauto-kai is finalized
        add("SubmarineSwitch").fromObject(submarineSwitch)
        quests.quests.setAll(quests.quests.map(String::toLowerCase))*/
        add("Quests").fromObject(quests)
    }

    fun delete(): Boolean {
        with(path()) {
            return if (Files.exists(this)) {
                Files.delete(this)
                logger.info("Deleted profile")
                logger.debug("Deleted ${this@KancolleAutoProfile} from $this")
                true
            } else {
                logger.warn("File doesn't exist, can't delete!")
                logger.debug("Couldn't delete $this")
                false
            }
        }
    }

    companion object Loader {
        private val loaderLogger = LoggerFactory.getLogger(KancolleAutoProfile.Loader::class.java)
        val DEFAULT_NAME = "[Current Profile]"
        val VALID_NODES = (1..12).map { it.toString() }
                .plus("ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("").filter { it.isNotEmpty() })
                .plus(listOf("Z1", "Z2", "Z3", "Z4", "Z5", "Z6", "Z7", "Z8", "Z9", "ZZ1", "ZZ2", "ZZ3"))
                .let {
                    FXCollections.observableList(it)
                }

        fun load(path: Path = Kaga.CONFIG.kcaKaiRootDirPath.resolve("config.ini")): KancolleAutoProfile {
            if (Files.exists(path)) {
                loaderLogger.info("Attempting to load KancolleAuto Profile")
                loaderLogger.debug("Loading KancolleAuto Profile from $path")
                val matcher = Pattern.compile("(.+?)-config\\.ini").matcher(path.fileName.toString())
                val name = if (matcher.matches()) {
                    matcher.group(1)
                } else {
                    var backupPath = path.resolveSibling("config.ini.bak")
                    var index = 0
                    while (Files.exists(backupPath)) {
                        backupPath = path.resolveSibling("config.ini.bak${index++}")
                    }
                    loaderLogger.info("Copied backup of existing configuration to $backupPath")
                    Files.copy(path, backupPath)
                    DEFAULT_NAME
                }
                val ini = Wini(path.toFile())

                val general = checkNotNull(ini["General"]?.toObject<General>()) { "Could not parse General section!" }
                val scheduledSleep = checkNotNull(ini["ScheduledSleep"]?.toObject<ScheduledSleep>()) { "Could not parse ScheduledSleep section!" }
                /* TODO Disabled temporarily till kcauto-kai is finalized
                val scheduledStop = checkNotNull(ini["ScheduledStop"]?.toObject<ScheduledStop>()) { "Could not parse ScheduledStop section!" }*/
                val expeditions = checkNotNull(ini["Expeditions"]?.toObject<Expeditions>()) { "Could not parse Expeditions section!" }
                val pvp = checkNotNull(ini["PvP"]?.toObject<Pvp>()) { "Could not parse PvP section!" }
                val sortie = checkNotNull(ini["Combat"]?.toObject<Sortie>()) { "Could not parse Combat section!" }
                /* TODO Disabled temporarily till kcauto-kai is finalized
                val submarineSwitch = checkNotNull(ini["SubmarineSwitch"]?.toObject<SubmarineSwitch>()) { "Could not parse SubmarineSwitch section!" } */
                val quests = checkNotNull(ini["Quests"]?.toObject<Quests>()) { "Could not parse Quests section!" }

                return KancolleAutoProfile(name, general, scheduledSleep,
                        /* TODO Disabled temporarily till kcauto-kai is finalized
                        scheduledStop,*/
                        expeditions, pvp, sortie,
                        /* TODO Disabled temporarily till kcauto-kai is finalized
                        submarineSwitch,*/ quests).apply {
                    loaderLogger.info("Loading KancolleAuto profile was successful")
                    loaderLogger.debug("Loaded $this")
                }
            } else {
                loaderLogger.debug("Config at $path not found, falling back to config.ini in kancolle-auto root")
                check(Kaga.CONFIG.isValid())
                return load()
            }
        }
    }

    enum class RecoveryMethod { BROWSER, KC3, KCV, KCT, EO, NONE }

    enum class ScheduledStopMode { TIME, EXPEDITION, SORTIE, PVP }

    enum class CombatFormation(val prettyString: String) {
        LINE_AHEAD("Line Ahead"), DOUBLE_LINE("Double Line"), DIAMOND("Diamond"),
        ECHELON("Echelon"), LINE_ABREAST("Line Abreast"), VANGUARD("Vanguard"), COMBINEDFLEET_1("Cruising Formation 1 (Anti-Sub)"),
        COMBINEDFLEET_2("Cruising Formation 2 (Forward)"), COMBINEDFLEET_3("Cruising Formation 3 (Ring)"), COMBINEDFLEET_4("Cruising Formation 4 (Battle)");

        companion object {
            fun fromPrettyString(string: String) = values().first { it.prettyString.equals(string, true) }
        }

        override fun toString(): String = name.toLowerCase()
    }

    enum class Submarines(val prettyString: String, val isSSV: Boolean?) {
        ALL("All", null), SS("SS", null), SSV("SSV", null), I_8("I-8", false),
        I_8_KAI("I-8 Kai", true), I_13("I-13", true), I_14("I-14", true),
        I_19("I-19", false), I_19_KAI("I-19 Kai", true), I_26("I-26", false),
        I_26_KAI("I-26 Kai", true), I_58("I-58", false), I_58_KAI("I-58 Kai", true),
        I_168("I-168", false), I_401("I-401", true), MARUYU("Maruyu", false),
        RO_500("Ro-500", false), U_511("U-511", false), LUIGI("Luigi", false),
        UIT_25("UIT-25", false), I_504("I-504", false);

        override fun toString() = prettyString.toLowerCase().replace(" ", "-")
    }

    enum class Engine(val prettyString: String) {
        LEGACY("Legacy"), LIVE("Live / Dynamic");

        companion object {
            fun fromPrettyString(string: String) = values().first { it.prettyString.equals(string, true) }
        }

        override fun toString() = name.toLowerCase()
    }

    enum class FleetMode(val prettyString: String, val value: String) {
        STANDARD("Standard", ""),
        CTF("Carrier Task Force", "ctf"),
        STF("Strike Task Force", "stf"),
        TRANSPORT("Transport Escort", "transport"),
        STRIKING("Striking Fleet", "striking");

        companion object {
            fun fromPrettyString(string: String) = values().first { it.prettyString.equals(string, true) }
        }

        override fun toString() = value
    }

    enum class DamageLevel(val prettyString: String, val value: String) {
        LIGHT("Light Damage", "minor"),
        MODERATE("Moderate Damage", "moderate"),
        CRITICAL("Critical Damage", "heavy");

        companion object {
            fun fromPrettyString(string: String) = values().first { it.prettyString.equals(string, true) }
        }

        override fun toString() = value
    }

    enum class SortieOptions(val value: String) {
        CHECK_FATIGUE("CheckFatigue"),
        RESERVE_DOCKS("ReserveDocks"),
        PORT_CHECK("PortCheck"),
        MEDAL_STOP("MedalStop");

        override fun toString() = value
    }

    class General(
            program: String = "Chrome"
            /* TODO Disabled temporarily till kcauto-kai is finalized
            recoveryMethod: RecoveryMethod = RecoveryMethod.KC3,
            basicRecovery: Boolean = true,
            sleepCycle: Int = 20,
            paranoia: Int = 1,
            sleepModifier: Int = 0*/
    ) {
        @JsonIgnore
        @IniConfig(key = "Program")
        val programProperty = SimpleStringProperty(program)
        @JsonIgnore
        @IniConfig(key = "JSTOffset", shouldRead = false)
        val jstOffsetProperty = ((TimeZone.getDefault().rawOffset - TimeZone.getTimeZone("Japan").rawOffset) / 3600000).let {
            SimpleIntegerProperty(it)
        }
        /* TODO Disabled temporarily till kcauto-kai is finalized
        @JsonIgnore @IniConfig(key = "RecoveryMethod") val recoveryMethodProperty = SimpleObjectProperty<RecoveryMethod>(recoveryMethod)
        @JsonIgnore @IniConfig(key = "BasicRecovery") val basicRecoveryProperty: BooleanProperty = SimpleBooleanProperty(basicRecovery)
        @JsonIgnore @IniConfig(key = "SleepCycle") val sleepCycleProperty: IntegerProperty = SimpleIntegerProperty(sleepCycle)
        @JsonIgnore @IniConfig(key = "Paranoia") val paranoiaProperty: IntegerProperty = SimpleIntegerProperty(paranoia)
        @JsonIgnore @IniConfig(key = "SleepModifier") val sleepModifierProperty: IntegerProperty = SimpleIntegerProperty(sleepModifier)*/

        @get:JsonProperty
        var program by programProperty
        @get:JsonProperty
        var jstOffset by jstOffsetProperty
        /* TODO Disabled temporarily till kcauto-kai is finalized
        @get:JsonProperty var recoveryMethod by recoveryMethodProperty
        @get:JsonProperty var basicRecovery by basicRecoveryProperty
        @get:JsonProperty var sleepCycle by sleepCycleProperty
        @get:JsonProperty var paranoia by paranoiaProperty
        @get:JsonProperty var sleepModifier by sleepModifierProperty*/
    }

    class ScheduledSleep(
            enabled: Boolean = true,
            startTime: String = "0030",
            length: Double = 3.5
    ) {
        @JsonIgnore
        @IniConfig(key = "Enabled")
        val enabledProperty = SimpleBooleanProperty(enabled)
        @JsonIgnore
        @IniConfig(key = "StartTime")
        val startTimeProperty = SimpleStringProperty(startTime)
        @JsonIgnore
        @IniConfig(key = "SleepLength")
        val lengthProperty = SimpleDoubleProperty(length)

        @get:JsonProperty
        var enabled by enabledProperty
        @get:JsonProperty
        var startTime by startTimeProperty
        @get:JsonProperty
        var length by lengthProperty
    }

    /* TODO Disabled temporarily till kcauto-kai is finalized
    class ScheduledStop(
            enabled: Boolean = false,
            mode: ScheduledStopMode = ScheduledStopMode.TIME,
            count: Int = 5
    ) {
        @JsonIgnore @IniConfig(key = "Enabled") val enabledProperty = SimpleBooleanProperty(enabled)
        @JsonIgnore @IniConfig(key = "Mode") val modeProperty = SimpleObjectProperty(mode)
        @JsonIgnore @IniConfig(key = "Count") val countProperty = SimpleIntegerProperty(count)

        @get:JsonProperty var enabled by enabledProperty
        @get:JsonProperty var mode by modeProperty
        @get:JsonProperty var count by countProperty
    }*/

    class Expeditions(
            enabled: Boolean = true,
            fleet2: List<String> = listOf("2"),
            fleet3: List<String> = listOf("5"),
            fleet4: List<String> = listOf("21")
    ) {
        @JsonIgnore
        @IniConfig(key = "Enabled")
        val enabledProperty = SimpleBooleanProperty(enabled)
        @JsonIgnore
        @IniConfig(key = "Fleet2")
        val fleet2Property = SimpleListProperty(FXCollections.observableList(fleet2))
        @JsonIgnore
        @IniConfig(key = "Fleet3")
        val fleet3Property = SimpleListProperty(FXCollections.observableList(fleet3))
        @JsonIgnore
        @IniConfig(key = "Fleet4")
        val fleet4Property = SimpleListProperty(FXCollections.observableList(fleet4))

        @get:JsonProperty
        var enabled by enabledProperty
        @get:JsonProperty
        var fleet2 by fleet2Property
        @get:JsonProperty
        var fleet3 by fleet3Property
        @get:JsonProperty
        var fleet4 by fleet4Property
    }

    class Pvp(
            enabled: Boolean = false
            /* TODO Disabled temporarily till kcauto-kai is finalized
            fleetComp: Int = 1*/
    ) {
        @JsonIgnore
        @IniConfig(key = "Enabled")
        val enabledProperty = SimpleBooleanProperty(enabled)
        /* TODO Disabled temporarily till kcauto-kai is finalized
        @JsonIgnore @IniConfig(key = "FleetComp") val fleetCompProperty = SimpleIntegerProperty(fleetComp)*/

        @get:JsonProperty
        var enabled by enabledProperty
        /* TODO Disabled temporarily till kcauto-kai is finalized
        @get:JsonProperty var fleetComp by fleetCompProperty*/
    }

    class Sortie(
            enabled: Boolean = false,
            engine: Engine = Engine.LEGACY,
            map: String = "1-1",
            nodes: Int = 5,
            fleetMode: FleetMode = FleetMode.STANDARD,
            nodeSelects: List<String> = emptyList(),
            formations: List<String> = emptyList(),
            nightBattles: List<String> = emptyList(),
            retreatLimit: DamageLevel = DamageLevel.CRITICAL,
            repairLimit: DamageLevel = DamageLevel.MODERATE,
            repairTimeLimit: String = "0030",
            lbasGroups: Set<String> = emptySet(),
            lbasGroup1Nodes: List<String> = emptyList(),
            lbasGroup2Nodes: List<String> = emptyList(),
            lbasGroup3Nodes: List<String> = emptyList(),
            miscOptions: Set<SortieOptions> = emptySet()
    ) {
        @JsonIgnore
        @IniConfig(key = "Enabled")
        val enabledProperty = SimpleBooleanProperty(enabled)
        @JsonIgnore
        @IniConfig(key = "Engine")
        val engineProperty = SimpleObjectProperty(engine)
        @JsonIgnore
        @IniConfig(key = "Map")
        val mapProperty = SimpleStringProperty(map)
        @JsonIgnore
        @IniConfig(key = "CombatNodes")
        val nodesProperty = SimpleIntegerProperty(nodes)
        @JsonIgnore
        @IniConfig(key = "FleetMode")
        val fleetModeProperty = SimpleObjectProperty(fleetMode)
        @JsonIgnore
        @IniConfig(key = "NodeSelects")
        val nodeSelectsProperty = SimpleListProperty(FXCollections.observableList(nodeSelects))
        @JsonIgnore
        @IniConfig(key = "Formations")
        val formationsProperty = SimpleListProperty(FXCollections.observableList(formations))
        @JsonIgnore
        @IniConfig(key = "NightBattles")
        val nightBattlesProperty = SimpleListProperty(FXCollections.observableList(nightBattles))
        @JsonIgnore
        @IniConfig(key = "RetreatLimit")
        val retreatLimitProperty = SimpleObjectProperty(retreatLimit)
        @JsonIgnore
        @IniConfig(key = "RepairLimit")
        val repairLimitProperty = SimpleObjectProperty(repairLimit)
        @JsonIgnore
        @IniConfig(key = "RepairTimeLimit")
        val repairTimeLimitProperty = SimpleStringProperty(repairTimeLimit)
        @JsonIgnore
        @IniConfig(key = "LBASGroups")
        val lbasGroupsProperty = SimpleSetProperty(FXCollections.observableSet(lbasGroups))
        @JsonIgnore
        @IniConfig(key = "LBASGroup1Nodes")
        val lbasGroup1NodesProperty = SimpleListProperty(FXCollections.observableList(lbasGroup1Nodes))
        @JsonIgnore
        @IniConfig(key = "LBASGroup2Nodes")
        val lbasGroup2NodesProperty = SimpleListProperty(FXCollections.observableList(lbasGroup2Nodes))
        @JsonIgnore
        @IniConfig(key = "LBASGroup3Nodes")
        val lbasGroup3NodesProperty = SimpleListProperty(FXCollections.observableList(lbasGroup3Nodes))
        @JsonIgnore
        @IniConfig(key = "MiscOptions")
        val miscOptionsProperty = SimpleSetProperty(FXCollections.observableSet(miscOptions))

        @get:JsonProperty
        var enabled by enabledProperty
        @get:JsonProperty
        var engine by engineProperty
        @get:JsonProperty
        var map by mapProperty
        @get:JsonProperty
        var nodes by nodesProperty
        @get:JsonProperty
        var fleetMode by fleetModeProperty
        @get:JsonProperty
        var nodeSelects by nodeSelectsProperty
        @get:JsonProperty
        var formations by formationsProperty
        @get:JsonProperty
        var nightBattles by nightBattlesProperty
        @get:JsonProperty
        var retreatLimit by retreatLimitProperty
        @get:JsonProperty
        var repairLimit by repairLimitProperty
        @get:JsonProperty
        var repairTimeLimit by repairTimeLimitProperty
        @get:JsonProperty
        var lbasGroups by lbasGroupsProperty
        @get:JsonProperty
        var lbasGroup1Nodes by lbasGroup1NodesProperty
        @get:JsonProperty
        var lbasGroup2Nodes by lbasGroup2NodesProperty
        @get:JsonProperty
        var lbasGroup3Nodes by lbasGroup3NodesProperty
        @get:JsonProperty
        var miscOptions by miscOptionsProperty
    }

    class SubmarineSwitch(
            enabled: Boolean = true,
            enabledSubs: List<Submarines> = listOf(Submarines.SS),
            replaceLimit: Int = 0,
            fatigueSwitch: Boolean = false,
            useBuckets: Boolean = false
    ) {
        @JsonIgnore
        @IniConfig(key = "Enabled")
        val enabledProperty = SimpleBooleanProperty(enabled)
        @JsonIgnore
        @IniConfig(key = "EnabledSubs")
        val enabledSubsProperty = SimpleListProperty(FXCollections.observableArrayList(enabledSubs))
        @JsonIgnore
        @IniConfig(key = "ReplaceLimit")
        val replaceLimitProperty = SimpleIntegerProperty(replaceLimit)
        @JsonIgnore
        @IniConfig(key = "FatigueSwitch")
        val fatigueSwitchProperty = SimpleBooleanProperty(fatigueSwitch)
        @JsonIgnore
        @IniConfig(key = "UseBuckets")
        val useBucketsProperty = SimpleBooleanProperty(useBuckets)

        @get:JsonProperty
        var enabled by enabledProperty
        @get:JsonProperty
        var enabledSubs by enabledSubsProperty
        @get:JsonProperty
        var replaceLimit by replaceLimitProperty
        @get:JsonProperty
        var fatigueSwitch by fatigueSwitchProperty
        @get:JsonProperty
        var useBuckets by useBucketsProperty
    }

    class Quests(
            enabled: Boolean = true
            /* TODO Disabled temporarily till kcauto-kai is finalized
            quests: List<String> = listOf("bd1", "bd2", "bd3", "bd4", "bd5", "bd6", "bd7", "bd8", "bw1", "bw2", "bw3", "bw4", "bw5", "bw6", "bw7", "bw8", "bw9", "bw10", "c2", "c3", "c4", "c8", "d2", "d3", "d4", "d9", "d11", "e3", "e4"),
            checkSchedule: Int = 5*/
    ) {
        @JsonIgnore
        @IniConfig(key = "Enabled")
        val enabledProperty = SimpleBooleanProperty(enabled)
        /* TODO Disabled temporarily till kcauto-kai is finalized
        @JsonIgnore @IniConfig(key = "Quests") val questsProperty = SimpleListProperty(FXCollections.observableArrayList(quests))
        @JsonIgnore @IniConfig(key = "CheckSchedule") val checkScheduleProperty = SimpleIntegerProperty(checkSchedule)*/

        @get:JsonProperty
        var enabled by enabledProperty
        /* TODO Disabled temporarily till kcauto-kai is finalized
        @get:JsonProperty var quests by questsProperty
        @get:JsonProperty var checkSchedule by checkScheduleProperty*/
    }


    override fun toString(): String = jacksonObjectMapper().writeValueAsString(this)
}
